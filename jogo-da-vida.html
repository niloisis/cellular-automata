<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autômato Celular 2D - Jogo da Vida</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            border: 1px solid #e2e8f0;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Autômato Celular 2D: O Jogo da Vida</h1>
            <p class="text-gray-600 mt-2">Uma simulação baseada nas regras de John Conway. Clique nas células para alterar seu estado.</p>
        </div>

        <!-- Canvas para a simulação -->
        <div class="flex justify-center mb-6">
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- Controles da Simulação -->
        <div class="flex flex-wrap justify-center items-center gap-3">
            <button id="startStopBtn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">Iniciar</button>
            <button id="resetBtn" class="px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">Aleatorizar</button>
            <button id="clearBtn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">Limpar</button>
             <div class="flex items-center space-x-2">
                <label for="speedRange" class="text-sm font-medium text-gray-700">Velocidade:</label>
                <input type="range" id="speedRange" min="10" max="500" value="100" class="w-32">
            </div>
        </div>
         <div id="infoPanel" class="text-center mt-4 text-gray-500 text-sm">
            <span>Geração: <span id="generationCount">0</span></span>
        </div>
    </div>

    <script>
        // --- Configuração Inicial ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const resolution = 10; // Tamanho de cada célula em pixels
        canvas.width = 600;
        canvas.height = 400;

        const COLS = canvas.width / resolution;
        const ROWS = canvas.height / resolution;

        let grid;
        let isRunning = false;
        let animationFrameId;
        let generationCount = 0;
        let simulationSpeed = 100; // ms por geração

        // --- Elementos da UI ---
        const startStopBtn = document.getElementById('startStopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearBtn = document.getElementById('clearBtn');
        const speedRange = document.getElementById('speedRange');
        const generationCounter = document.getElementById('generationCount');

        // --- Lógica do Autômato Celular ---

        /**
         * Cria uma nova grade (grid) preenchida com zeros (células mortas).
         * @returns {Array<Array<number>>} Uma matriz 2D representando a grade.
         */
        function createGrid() {
            return new Array(COLS).fill(null)
                .map(() => new Array(ROWS).fill(0));
        }
        
        /**
         * Preenche a grade com valores aleatórios (0 ou 1).
         */
        function randomizeGrid() {
            grid = grid.map(col => col.map(() => Math.floor(Math.random() * 2)));
            generationCount = 0;
            updateInfoPanel();
            drawGrid();
        }

        /**
         * Limpa a grade, definindo todas as células como mortas.
         */
        function clearGrid() {
            grid = createGrid();
            generationCount = 0;
            updateInfoPanel();
            drawGrid();
        }

        /**
         * Desenha a grade no canvas.
         */
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let col = 0; col < COLS; col++) {
                for (let row = 0; row < ROWS; row++) {
                    const cell = grid[col][row];
                    ctx.beginPath();
                    ctx.rect(col * resolution, row * resolution, resolution, resolution);
                    ctx.fillStyle = cell ? '#2d3748' : 'white'; // Célula viva: cinza escuro, morta: branco
                    ctx.fill();
                    ctx.strokeStyle = '#e2e8f0'; // Cor da grade
                    ctx.stroke();
                }
            }
        }

        /**
         * Calcula a próxima geração da grade com base nas regras do Jogo da Vida.
         */
        function computeNextGeneration() {
            const nextGenGrid = createGrid();

            for (let col = 0; col < COLS; col++) {
                for (let row = 0; row < ROWS; row++) {
                    const cell = grid[col][row];
                    const neighbors = countNeighbors(col, row);

                    // Aplica as regras do Jogo da Vida
                    if (cell === 1 && (neighbors < 2 || neighbors > 3)) {
                        nextGenGrid[col][row] = 0; // Morte por solidão ou superpopulação
                    } else if (cell === 0 && neighbors === 3) {
                        nextGenGrid[col][row] = 1; // Nascimento
                    } else {
                        nextGenGrid[col][row] = cell; // Permanece no mesmo estado
                    }
                }
            }
            grid = nextGenGrid;
            generationCount++;
        }

        /**
         * Conta o número de vizinhos vivos de uma determinada célula.
         * Usa uma grade "toroidal" (as bordas se conectam).
         * @param {number} x - A coordenada x da célula.
         * @param {number} y - A coordenada y da célula.
         * @returns {number} O número de vizinhos vivos.
         */
        function countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i < 2; i++) {
                for (let j = -1; j < 2; j++) {
                    if (i === 0 && j === 0) {
                        continue;
                    }
                    // Lógica para a grade toroidal
                    const col = (x + i + COLS) % COLS;
                    const row = (y + j + ROWS) % ROWS;
                    count += grid[col][row];
                }
            }
            return count;
        }
        
        function updateInfoPanel() {
            generationCounter.textContent = generationCount;
        }

        // --- Loop da Animação e Controles ---
        let lastUpdateTime = 0;

        function gameLoop(timestamp) {
            if (!isRunning) return;

            if (timestamp - lastUpdateTime >= simulationSpeed) {
                computeNextGeneration();
                drawGrid();
                updateInfoPanel();
                lastUpdateTime = timestamp;
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startSimulation() {
            if (isRunning) return;
            isRunning = true;
            startStopBtn.textContent = 'Parar';
            startStopBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            startStopBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            lastUpdateTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function stopSimulation() {
            if (!isRunning) return;
            isRunning = false;
            startStopBtn.textContent = 'Iniciar';
            startStopBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            startStopBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            cancelAnimationFrame(animationFrameId);
        }

        // --- Event Listeners ---
        startStopBtn.addEventListener('click', () => {
            if (isRunning) {
                stopSimulation();
            } else {
                startSimulation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopSimulation();
            randomizeGrid();
        });
        
        clearBtn.addEventListener('click', () => {
            stopSimulation();
            clearGrid();
        });

        speedRange.addEventListener('input', (e) => {
            // Inverte o valor para que o slider para a direita signifique mais rápido
            simulationSpeed = 510 - e.target.value;
        });
        
        canvas.addEventListener('click', (event) => {
            if (isRunning) return; // Não permite edição durante a simulação

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const col = Math.floor(x / resolution);
            const row = Math.floor(y / resolution);

            // Inverte o estado da célula
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                grid[col][row] = grid[col][row] ? 0 : 1;
                drawGrid();
            }
        });

        // --- Inicialização ---
        grid = createGrid();
        drawGrid();

    </script>
</body>
</html>
